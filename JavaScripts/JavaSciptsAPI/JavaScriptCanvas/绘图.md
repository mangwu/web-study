# 绘图

## canvas发展

+ 早期使用img元素引入图像
+ 后来有了background-image和SVG图像格式
+ 为了支持动态位图，引入了canvas画布元素
+ 以及Canvas API用于展示动态元素
+ 为了支持3D画布，演化为了WebGL

## canvas使用

+ 引入canvas元素

  ```html
  <canvas class="canvasName">
  	<p>反馈信息</p>
  </canvas>
  ```

+ 设置width和height

  ```js
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  ```

+ 设置body边距和溢出属性，让整个页面只显示画布

  ```
  body {
  	margin: 0;
  	overflow: hidden;
  }
  ```



+ 获取画布的上下文

  需要获取对绘画区域的特殊引用（上下文）用来绘图，通过HTMLCanvasElement.getContext()方法
  ```js
  var ctx = canvas.getContext('2d');
  // 2d绘图就使用参数'2d'，还可以选用webgl和webgl2
  ```

  ctx是一个CanvasRenderingContext2D对象，画布上所有操作都涉及到这个对象

+ 对画布的上下文进行初步使用（canvas API的初步使用)

  ```js
  ctx.fillStyle = 'rgb(0, 0, 0)';
  ctx.fillRect(0, 0, width, height);
  ```

  

## 2d 画布基础

+ 2d绘画上下文对象：CanvasRenderingContext2D
  + 提供了许多操作和属性
+ 2d绘画的基本属性
  + 画布左上角为默认原点坐标 (0， 0)
  + 横坐标x向右延伸
  + 纵坐标y向下延伸
+ 2d绘图操作实现
  + 基于原始矩形模型实现
  + 也可通过追踪一个特定路径后填充颜色实现

### 简单矩形

+ 在JS代码添加如下两行

  ```js
  ctx.fillStyle = 'rgb(255, 0, 0)';
  ctx.fillRect(50, 50, 100, 150);
  // (50, 50) 坐标为矩形左上角点，
  // 宽度100， 高度150；
  ```

  出现了一个宽100，高150的红色矩形

+ 再次添加参数不一样的重复代码

  ```
  ctx.fillStyle = 'rgb(0, 255, 0)';
  ctx.fillRect(100, 100, 150, 125);
  // (50, 50) 坐标为矩形左上角点，
  // 宽度100， 高度150；
  ```

  绘制矩形，线等操作按出现顺序依次进行，重叠时新层会覆盖旧层。

+ 指定透明颜色绘制半透明图形

  ```
  ctx.fillStyle = 'rgba(125, 54, 254, 0.75)';
  ctx.fillRect(25, 100, 200, 230);
  ```

### 描边和线条宽度

#### 描边stroke

+ 绘制仅包含外部框线(stroke)的矩形
+ 使用strokeStyle属性设置描边颜色
+ 使用strokeRect方法绘制矩形轮廓

```
ctx.strokeStyle = 'rgb(240, 255, 240)';
ctx.strokeRect(25, 25, 100, 100);
```

#### 线条宽度

+ 使用lineWidth属性设置线条宽度
+ 设置代码放在上两条中间

```
ctx.lineWidth = 5;
```

+ ##### 线条宽度按照矩形边框虚线向两边扩张



### 绘制路径

#### 路径

+ 包含钢笔运行的精确路径的代码以确定图形的形状

+ 画布提供了许多函数来绘制**直线、圆、贝塞尔曲线**

+ ##### 绘制路径的通用方法

  + beginPath():在钢笔当前所在位置开始绘制一条路径。**新画布中，钢笔起始位置为(0,0)**
  + moveTo(): 将钢笔移动到另一个坐标点
  + fill(): 通过为当前所绘制路径的区域填充颜色来绘制一个新的填充形状
  + stroke()：通过为当前绘制路径的区域描边，来绘制一个只有边框的形状
  + 路径可以使用lineWidth和fillStyle和strokeStyle功能

  ```
  ctx.fillStyle = 'rgb(255, 200, 150)';
  ctx.beginPath();
  ctx.moveTo(50, 50);
  // 绘制路径
  ctx.fill();
  ```



#### 画圆

使用arc()方法绘制圆

+ 通过绘制连续的点来绘制整个圆
+ 参数
  + x，圆心x坐标
  + y,圆心y坐标
  + radius， 半径长度
  + startDeg,开始角度，从右边，开始，负数或大数自动加（减）上2npi存为[0, 2pi]上的角度
    + 0度设为水平向右
  + endDeg，结束角度，从开始角度开始，顺时针开始。
  + 绘制方向，false是顺时针，true是逆时针

+ 通过在绘制fill()之前使用lineTo()方法到圆心可以得到饼状图

  ```js
  // 画实心圆
  ctx.fillStyle = 'rgba(120, 250, 200)';
  ctx.beginPath(); 
  ctx.arc(650, 400, 80, degToRad(-30), degToRad(30), true);
  ctx.lineTo(650, 400);
  ctx.fill();
  ```



### 绘制文本

+ fillText()：绘制有填充色的文本

+ strokeText():绘制文本外边框（描边)

+ 两个函数的参数

  + 需要绘制的文字
  + 文本框左上顶点的X、Y坐标

+ font:指定字号，字宽，字体等

  ```js
  // 绘制文本
  ctx.fillStyle = 'rgb(250, 240, 120)';
  ctx.font = '40px "微软雅黑", sans-serif';
  ctx.fillText('Canvas Text', 500, 500);
  
  // 绘制空心文本
  ctx.strokeStyle = 'rgb(240, 199, 240)';
  ctx.font = '55px "微软雅黑", sans-serif';
  ctx.lineWidth = 1;
  ctx.strokeText('Canvas Text', 400, 600);
  ```

  

### 绘制图片

+ drawImage()方法可以将图片绘制在画布上

  + 参数1：需要渲染的图片
  + 参数2：x坐标
  + 参数3：y坐标

+ 需要渲染的图片是一个HTMLImageElement()对象

  ```
  var image = new Image();
  image.src = url;
  ```

+ 可选参数：用于改变图片尺寸

  + 参数2、3表示裁剪部分左上顶点的坐标，参考原点为原图片本身左上角坐标
  + 参数4、5裁剪部分的长宽
  + 参数6、7裁剪部分左上顶点在画布中的坐标位置（参考原点为画布左上顶点）
  + 参数8、9裁剪部分在画布中绘制的长宽

### 循环和动画

+ 画布提供可编程图形

#### 循环

+ 设置原点

  ```js
  ctx.translate(width/2, height/2)
  ```

+ 使用for循环

+ 设置每次循环的路径起始点

  ```js
  ctx.fillStyle = 'rgba(x,x,x)'; //x可以根据循环的次数变换
  ctx.beginPath();
  ctx.moveTo(moveOffset, moveOffset); //起始点
  ```

+ 绘制图形(等边三角形)

  ```js
  ctx.lineTo(moveOffset + loops, moveOffset);
  var triHeight = loops/2 * Math.tan(degToRad(60));
  ctx.lineTo(moveOffset+(loops/2), moveOffset+triHeight);
  ctx.lineTo(moveOffset, moveOffset);
  ctx.fill();
  ```

+ 修改循环和移动变量，旋转图形

  ```
  loops--;
  moveOffset += 0.7;
  ctx.rotate(degToRad(5));
  ```

  

